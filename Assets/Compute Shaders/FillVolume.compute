// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform int _AtomCount;
uniform int _VolumeSize;

uniform float _Scale;
uniform float _SurfaceSmoothness;

StructuredBuffer<float4> _AtomBuffer;
RWStructuredBuffer<uint> _VoxelBuffer;
RWStructuredBuffer<uint> _NormalBuffer;




uint float2Touint(float2 f2Value)
{
	return (f32tof16(f2Value.x) + (f32tof16(f2Value.y) << 16));
}

// Unpacks a uint to a float2
float2 uintTofloat2(uint uValue)
{
	return float2(f16tof32(uValue), f16tof32(uValue >> 16));
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= _AtomCount) return;

	float4 atom = _AtomBuffer[id.x] * _Scale;	
	atom.xyz += _VolumeSize * 0.5;
	
	float atomSquare = atom.w * atom.w;
	float evalSize = atom.w * 2;
	float SR = 1.4f;
	
	for(int x = -evalSize; x <= evalSize; x ++)
	{
		for(int y = -evalSize; y <= evalSize; y ++)
		{
			for(int z = -evalSize; z <= evalSize; z ++)
			{	
				int3 local = int3(x,y,z);
				int3 global = atom.xyz + local;
				
				int idx = global.x + global.y * _VolumeSize + global.z * _VolumeSize * _VolumeSize;
					

				if(any(step(global, float3(-1,-1,-1)))) continue;
				if(any(step(float3(_VolumeSize,_VolumeSize,_VolumeSize), global))) continue;

				
				float f = atom.w - sqrt(dot(local, local));
				float3 n = normalize(local - atom.xyz);
				uint _vox_buf = _VoxelBuffer[idx];
				uint _nor_buf = _NormalBuffer[idx];
				float2 a1 = uinTofloat2(_vox_buf);
				float2 a2 = uinTofloat2(_nor_buf);
				float prev_f = a1.x;
				float3 prev_n =  float3(a1.y,a2.x,a2.y);
				float k = dot(n,prev_n);
				float s = 1.0f-sin(k*0.78f);
				float XR = s*SR;
				float disc = 2*XR*XR - prev_f*prev_f + 2*prev_f*f - f*f;
				if (prev_f<=(f+XR) && f<=(prev_f+XR)) {
					float sq_disc = sqrt(disc);
					prev_n = 0.5*(prev_n+n-(f*prev_n+prev_f*n-prev_f*prev_n-f*n)/sq_disc);
					//XD=normalize(XD);
					prev_f = 0.5*(2*XR + prev_f + f - sq_disc);
					prev_n=prev_n*(1.0/(1.0+prev_f*prev_f*length(prev_n)));
				} else if (f>prev_f) {
					prev_f = f;
					prev_n = n;
				}
				int original_value = 0;				
				uint _vox_buf = float2Touint(float2(prev_f, prev_n.x));
				uint _nor_buf = float2Touint(float2(prev_n.y, prev_n.z));
				float prev_f = a1.x;
				float3 prev_n =  float3(a1.y,a2.x,a2.y);
				InterlockedExchange(_VoxelBuffer[idx], _vox_buf, original_value);
				InterlockedExchange(_NormalBuffer[idx], _nor_buf, original_value3);		
			}
		}
	}    
}