// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

uniform int _AtomCount;
uniform int _VolumeSize;

uniform float _Scale;
uniform float _SurfaceSmoothness;

StructuredBuffer<float4> _AtomBuffer;
RWStructuredBuffer<int4> _VoxelBuffer;
RWBuffer<uint> _VoxelFlagBuffer;





uint float2Touint(float2 f2Value)
{
	return (f32tof16(f2Value.x) + (f32tof16(f2Value.y) << 16));
}

// Unpacks a uint to a float2
float2 uintTofloat2(uint uValue)
{
	return float2(f16tof32(uValue), f16tof32(uValue >> 16));
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= _AtomCount) return;

	float4 atom = _AtomBuffer[id.x] * _Scale;	
	atom.xyz += _VolumeSize * 0.5;
	
	float atomSquare = atom.w * atom.w;
	float evalSize = atom.w * 2;
	float SR = 1.4f*_Scale;
	
	for(int x = -evalSize; x <= evalSize; x ++)
	{
		for(int y = -evalSize; y <= evalSize; y ++)
		{
			for(int z = -evalSize; z <= evalSize; z ++)
			{	
				int3 local = int3(x,y,z);
				int3 global = atom.xyz + local;
				
				int idx = global.x + global.y * _VolumeSize + global.z * _VolumeSize * _VolumeSize;
					

				if(any(step(global, float3(-1,-1,-1)))) continue;
				if(any(step(float3(_VolumeSize,_VolumeSize,_VolumeSize), global))) continue;

				
				float f = atom.w - sqrt(dot(local, local));
				uint readEnabled=1;
				int iter=0;
				[allow_uav_condition]
				while (readEnabled!=0 && iter<500){
					InterlockedCompareExchange(_VoxelFlagBuffer[idx],0,1,readEnabled);
					iter++;
				}
				int4 _vox_buf = _VoxelBuffer[idx];
				float prev_f = _vox_buf.x / 1000.0f;
				int original_value = 0;	
				float3 n = normalize(local - atom.xyz);
				float3 prev_n = float3(_vox_buf.y / 1000.0f,_vox_buf.z / 1000.0f,_vox_buf.w / 1000.0f);
				float k = dot(n,prev_n);
				float s = 1.0f-sin(k*0.78f);
				float XR = s*SR;
//				float XR = SR;
				float disc = 2*XR*XR - prev_f*prev_f + 2*prev_f*f - f*f;
				if (prev_f<=(f+XR) && f<=(prev_f+XR)) {
					float sq_disc = sqrt(disc);
					prev_n = 0.5*(prev_n+n-(f*prev_n+prev_f*n-prev_f*prev_n-f*n)/sq_disc);
					prev_f = 0.5*(2*XR + prev_f + f - sq_disc);
					prev_n=prev_n*(1.0/(1.0+prev_f*prev_f*length(prev_n)));
				} else if (f>prev_f) {
					prev_f = f;
					prev_n = n;
				}
//				prev_n = normalize(prev_n);
				_VoxelBuffer[idx] = int4(prev_f * 1000,prev_n.x * 1000,prev_n.y * 1000,prev_n.z * 1000);
				InterlockedExchange(_VoxelFlagBuffer[idx],0,original_value);
			}
		}    
	}
}